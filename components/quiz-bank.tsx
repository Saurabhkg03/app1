"use client"
import { doc, deleteDoc, collection, query, where, setDoc, onSnapshot } from "firebase/firestore"
import { FileText, Edit3, Trash2, Download } from "lucide-react"
import { db } from "@/lib/firebase"
import { appId } from "@/lib/config"
import { getAuth } from "firebase/auth"
import { useEffect, useState } from "react"
import jsPDF from "jspdf"

export function QuizBank({
  quizzes,
  onEdit,
}: {
  quizzes: any[]
  onEdit: (quiz: any) => void
}) {
  const handleDelete = async (quizId: string, title: string) => {
    const confirmed = prompt(`Type "DELETE" to confirm deletion of quiz: "${title}"`)
    if (confirmed !== "DELETE") return
    try {
      const uid = getAuth().currentUser!.uid
      const quizRef = doc(db, "artifacts", appId, "users", uid, "quizzes", quizId)
      await deleteDoc(quizRef)
    } catch (e) {
      console.error("Error deleting quiz:", e)
    }
  }

  const handleExport = (quiz: any, format: "Word" | "PDF" | "Google Form" | "JSON") => {
    const generateHtmlContent = () => {
      let html = `<!DOCTYPE html><html><head><title>${quiz.title}</title><style>
                body{font-family: Arial, sans-serif; margin: 40px;} 
                h1{color: #3f51b5;} 
                .question-container{margin-bottom: 20px; border-left: 4px solid #ccc; padding-left: 10px;}
                .question-title{font-weight: bold;}
                .options-list{list-style-type: lower-alpha; padding-left: 20px;}
                .answer{font-weight: bold; color: #4CAF50;}
                .explanation{font-style: italic; color: #666;}
            </style></head><body>`
      html += `<h1>${quiz.title}</h1>`
      quiz.questions.forEach((q: any, index: number) => {
        html += `<div class="question-container">
                    <p class="question-title">${index + 1}. ${q.question} (${q.type})</p>`
        if (q.options && q.options.length) {
          html += `<ul class="options-list">`
          q.options.forEach((opt: string) => {
            html += `<li>${opt}</li>`
          })
          html += `</ul>`
        }
        html += `<p class="answer">Correct Answer: ${q.correctAnswer}</p>
                   <p class="explanation">Explanation: ${q.explanation}</p>
                 </div>`
      })
      html += `</body></html>`
      return html
    }

    const generateTextContent = (isForm: boolean) => {
      let text = isForm
        ? `--- Google Form Import Data ---\nTitle: ${quiz.title}\nDescription: Generated by EduQuizAI\n\n`
        : `--- EDUQUIZAI: ${quiz.title} ---\n\n`

      quiz.questions.forEach((q: any, index: number) => {
        text += `Q${index + 1}: ${q.question} [Type: ${q.type}]\n`
        if (q.options && q.options.length) {
          q.options.forEach((opt: string, oIndex: number) => {
            text += `   ${String.fromCharCode(65 + oIndex)}. ${opt}\n`
          })
        }
        text += `   CORRECT ANSWER: ${q.correctAnswer}\n`
        text += `   EXPLANATION: ${q.explanation}\n\n`
      })
      return text
    }
    
    const filename = `${quiz.title.replace(/\s/g, "_")}_Export`

    if (format === "Word") {
      const content = generateHtmlContent()
      const blob = new Blob([content], { type: "application/msword" })
      const url = URL.createObjectURL(blob)
      const a = document.createElement("a")
      a.href = url
      a.download = `${filename}.doc`
      a.click()
      URL.revokeObjectURL(url)
    } else if (format === "PDF") {
        const doc = new jsPDF()
        doc.setFont("Helvetica")
        doc.setFontSize(16)
        doc.text(quiz.title, 10, 20)
        
        let y = 30
        
        quiz.questions.forEach((q:any, index:number) => {
            if (y > 280) {
                doc.addPage()
                y = 20
            }
            doc.setFontSize(12)
            doc.setFont("Helvetica", "bold")
            const questionText = `${index + 1}. ${q.question} (${q.type})`
            const splitQuestion = doc.splitTextToSize(questionText, 180)
            doc.text(splitQuestion, 10, y)
            y += (splitQuestion.length * 5)
            
            doc.setFont("Helvetica", "normal")
            if (q.options && q.options.length) {
                q.options.forEach((opt:string, oIndex:number) => {
                    doc.text(`${String.fromCharCode(97 + oIndex)}. ${opt}`, 15, y)
                    y += 7
                })
            }

            doc.setTextColor(0, 150, 0)
            doc.text(`Correct Answer: ${q.correctAnswer}`, 15, y)
            y += 7
            
            doc.setTextColor(100, 100, 100)
            doc.setFont("Helvetica", "italic")
            const explanationText = `Explanation: ${q.explanation}`
            const splitExplanation = doc.splitTextToSize(explanationText, 170)
            doc.text(splitExplanation, 15, y)
            y += (splitExplanation.length * 5) + 5
            
            doc.setTextColor(0, 0, 0) // Reset color
            doc.setFont("Helvetica", "normal")
        })

        doc.save(`${filename}.pdf`)

    } else if (format === "Google Form") {
      const content = generateTextContent(true)
      const blob = new Blob([content], { type: "text/plain" })
      const url = URL.createObjectURL(blob)
      const a = document.createElement("a")
      a.href = url
      a.download = `${filename}_GoogleForm.txt`
      a.click()
      URL.revokeObjectURL(url)
    } else if (format === "JSON") {
        const content = JSON.stringify(quiz, null, 2)
        const blob = new Blob([content], { type: "application/json" })
        const url = URL.createObjectURL(blob)
        const a = document.createElement("a")
        a.href = url
        a.download = `${filename}.json`
        a.click()
        URL.revokeObjectURL(url)
    }
     else {
      console.error("Unknown export format.")
      return
    }

  }

  const [classes, setClasses] = useState<Array<{ id: string; name: string; code: string }>>([])

  useEffect(() => {
    const uid = getAuth().currentUser?.uid
    if (!uid) return
    const clsRef = collection(db, "artifacts", appId, "classes")
    const q = query(clsRef, where("ownerId", "==", uid))
    const unsub = onSnapshot(q, (snap) => {
      setClasses(snap.docs.map((d) => ({ id: d.id, ...(d.data() as any) })))
    })
    return () => unsub()
  }, [])

  const handleAssignToClass = async (clsId: string, quiz: any) => {
    try {
      const uid = getAuth().currentUser!.uid
      const assignedRef = doc(db, "artifacts", appId, "classes", clsId, "assigned", quiz.id)
      await setDoc(assignedRef, {
        quizId: quiz.id,
        teacherId: uid,
        classId: clsId,
        title: quiz.title,
        questions: quiz.questions,
        createdAt: new Date().toISOString(),
      })
      alert(`Assigned "${quiz.title}" to class successfully.`)
    } catch (e) {
      console.error("Error assigning quiz:", e)
      alert("Failed to assign quiz. See console for details.")
    }
  }

  return (
    <div className="space-y-6">
      <h2 className="text-2xl font-bold text-gray-800 flex items-center">
        <FileText className="w-6 h-6 mr-2 text-primary" /> Question Bank ({quizzes.length})
      </h2>

      {quizzes.length === 0 ? (
        <div className="p-8 text-center bg-gray-50 rounded-xl border border-dashed border-gray-300 text-gray-500">
          Your question bank is empty. Generate a quiz to save your first set of questions!
        </div>
      ) : (
        <div className="space-y-4">
          {quizzes.map((quiz: any) => (
            <div
              key={quiz.id}
              className="p-4 bg-white rounded-xl shadow-md border border-gray-100 flex justify-between items-center transition hover:shadow-lg"
            >
              <div>
                <h3 className="text-lg font-semibold text-gray-800">{quiz.title}</h3>
                <p className="text-sm text-gray-500">
                  {quiz.questions.length} Questions • Saved: {new Date(quiz.createdAt).toLocaleDateString()}
                </p>
                <p
                  className={`text-xs mt-1 font-semibold ${quiz.totalAttempts > 0 ? "text-primary" : "text-gray-400"}`}
                >
                  Attempts: {quiz.totalAttempts} • Avg. Score:{" "}
                  {quiz.totalAttempts > 0 ? `${quiz.avgScore.toFixed(1)}%` : "N/A"}
                </p>
              </div>
              <div className="flex items-center space-x-3">
                {classes.length > 0 && (
                  <select
                    aria-label="Assign to class"
                    className="text-sm border rounded-lg px-2 py-1"
                    defaultValue=""
                    onChange={(e) => {
                      const clsId = e.target.value
                      if (!clsId) return
                      handleAssignToClass(clsId, quiz)
                      e.currentTarget.value = ""
                    }}
                  >
                    <option value="" disabled>
                      Assign to class…
                    </option>
                    {classes.map((c) => (
                      <option key={c.id} value={c.id}>
                        {c.name} ({c.code})
                      </option>
                    ))}
                  </select>
                )}

                {/* Export action button */}
                <div className="relative group">
                  <button
                    className="p-2 text-secondary hover:bg-secondary/10 rounded-full transition flex items-center text-sm"
                    title="Export Quiz"
                  >
                    <Download className="w-5 h-5" />
                  </button>
                  <div className="absolute right-0 mt-2 w-48 rounded-md shadow-lg bg-white ring-1 ring-black ring-opacity-5 z-20 opacity-0 group-hover:opacity-100 transition-opacity">
                    <div className="py-1">
                      {(["Word", "PDF", "Google Form", "JSON"] as const).map((format) => (
                        <a
                          key={format}
                          href="#"
                          onClick={(e) => {
                            e.preventDefault()
                            handleExport(quiz, format)
                          }}
                          className="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100"
                        >
                          Export as {format}
                        </a>
                      ))}
                    </div>
                  </div>
                </div>

                {/* Edit action button */}
                <button
                  onClick={() => onEdit(quiz)}
                  title="Edit Quiz"
                  className="p-2 text-primary hover:bg-primary/10 rounded-full transition"
                >
                  <Edit3 className="w-5 h-5" />
                </button>

                {/* Delete action button */}
                <button
                  onClick={() => handleDelete(quiz.id, quiz.title)}
                  title="Delete Quiz"
                  className="p-2 text-error hover:bg-error/10 rounded-full transition"
                >
                  <Trash2 className="w-5 h-5" />
                </button>
              </div>
            </div>
          ))}
        </div>
      )}
    </div>
  )
}